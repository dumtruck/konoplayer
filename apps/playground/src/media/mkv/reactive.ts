import {
  type EbmlTagType,
  EbmlStreamDecoder,
  EbmlTagIdEnum,
  EbmlTagPosition,
} from 'konoebml';
import {
  Observable,
  from,
  switchMap,
  share,
  defer,
  EMPTY,
  of,
  filter,
  finalize,
  isEmpty,
  map,
  merge,
  raceWith,
  reduce,
  scan,
  shareReplay,
  take,
  takeUntil,
  withLatestFrom,
} from 'rxjs';
import { createRangedStream, type CreateRangedStreamOptions } from '@/fetch';
import {
  SegmentSystem,
  SEEK_ID_KAX_CUES,
  type CueSystem,
  type SegmentComponent,
  SEEK_ID_KAX_TAGS,
} from './model';
import { isTagIdPos, waitTick } from './util';
import type { ClusterType } from './schema';

export interface CreateRangedEbmlStreamOptions
  extends CreateRangedStreamOptions {}

export function createRangedEbmlStream({
  url,
  byteStart = 0,
  byteEnd,
}: CreateRangedEbmlStreamOptions): Observable<{
  ebml$: Observable<EbmlTagType>;
  totalSize?: number;
  response: Response;
  body: ReadableStream<Uint8Array>;
  controller: AbortController;
}> {
  const stream$ = from(createRangedStream({ url, byteStart, byteEnd }));

  return stream$.pipe(
    switchMap(({ controller, body, totalSize, response }) => {
      let requestCompleted = false;
      const originRequest$ = new Observable<EbmlTagType>((subscriber) => {
        body
          .pipeThrough(
            new EbmlStreamDecoder({
              streamStartOffset: byteStart,
              collectChild: (child) => child.id !== EbmlTagIdEnum.Cluster,
              backpressure: {
                eventLoop: waitTick,
              },
            })
          )
          .pipeTo(
            new WritableStream({
              write: async (tag) => {
                await waitTick();
                subscriber.next(tag);
              },
              close: () => {
                if (!requestCompleted) {
                  requestCompleted = true;
                  subscriber.complete();
                }
              },
            })
          )
          .catch((error) => {
            if (requestCompleted && error?.name === 'AbortError') {
              return;
            }
            requestCompleted = true;
            subscriber.error(error);
          });

        return () => {
          requestCompleted = true;
          controller.abort();
        };
      }).pipe(
        share({
          resetOnComplete: false,
          resetOnError: false,
          resetOnRefCountZero: true,
        })
      );

      const ebml$ = defer(() =>
        requestCompleted ? EMPTY : originRequest$
      ).pipe(
        share({
          resetOnError: false,
          resetOnComplete: true,
          resetOnRefCountZero: true,
        })
      );

      return of({
        ebml$,
        totalSize,
        response,
        body,
        controller,
      });
    })
  );
}

export interface CreateEbmlControllerOptions
  extends Omit<CreateRangedEbmlStreamOptions, 'byteStart' | 'byteEnd'> {}

export function createEbmlController({
  url,
  ...options
}: CreateEbmlControllerOptions) {
  const request$ = createRangedEbmlStream({
    ...options,
    url,
    byteStart: 0,
  });

  const controller$ = request$.pipe(
    map(({ totalSize, ebml$, response, controller }) => {
      const head$ = ebml$.pipe(
        filter(isTagIdPos(EbmlTagIdEnum.EBML, EbmlTagPosition.End)),
        take(1),
        shareReplay(1)
      );

      console.debug(
        `stream of video "${url}" created, total size is ${totalSize ?? 'unknown'}`
      );

      const segmentStart$ = ebml$.pipe(
        filter((s) => s.position === EbmlTagPosition.Start),
        filter((tag) => tag.id === EbmlTagIdEnum.Segment)
      );

      /**
       * while [matroska v4](https://www.matroska.org/technical/elements.html) doc tell that there is only one segment in a file
       * some mkv generated by strange tools will emit several
       */
      const segments$ = segmentStart$.pipe(
        map((startTag) => {
          const segment = new SegmentSystem(startTag);
          const clusterSystem = segment.cluster;
          const seekSystem = segment.seek;

          const segmentEnd$ = ebml$.pipe(
            filter(isTagIdPos(EbmlTagIdEnum.Segment, EbmlTagPosition.End)),
            filter((tag) => tag.id === EbmlTagIdEnum.Segment),
            take(1)
          );

          const clusterStart$ = ebml$.pipe(
            filter(isTagIdPos(EbmlTagIdEnum.Cluster, EbmlTagPosition.Start)),
            take(1),
            shareReplay(1)
          );

          const meta$ = ebml$.pipe(
            takeUntil(clusterStart$.pipe(raceWith(segmentEnd$))),
            share({
              resetOnComplete: false,
              resetOnError: false,
              resetOnRefCountZero: true,
            })
          );

          const withMeta$ = meta$.pipe(
            reduce((segment, meta) => segment.scanHead(meta), segment),
            map(segment.completeHeads.bind(segment)),
            take(1),
            shareReplay(1)
          );

          const withRemoteCues$ = withMeta$.pipe(
            switchMap((s) => {
              const cueSystem = s.cue;
              const seekSystem = s.seek;
              if (cueSystem.prepared) {
                return EMPTY;
              }
              const remoteCuesTagStartOffset =
                seekSystem.seekOffsetBySeekId(SEEK_ID_KAX_CUES);
              if (remoteCuesTagStartOffset! >= 0) {
                return createRangedEbmlStream({
                  ...options,
                  url,
                  byteStart: remoteCuesTagStartOffset,
                }).pipe(
                  switchMap((req) => req.ebml$),
                  filter(isTagIdPos(EbmlTagIdEnum.Cues, EbmlTagPosition.End)),
                  withLatestFrom(withMeta$),
                  map(([cues, withMeta]) => {
                    withMeta.cue.prepareCuesWithTag(cues);
                    return withMeta;
                  })
                );
              }
              return EMPTY;
            }),
            take(1),
            shareReplay(1)
          );

          const withLocalCues$ = withMeta$.pipe(
            switchMap((s) => (s.cue.prepared ? of(s) : EMPTY)),
            shareReplay(1)
          );

          const withRemoteTags$ = withMeta$.pipe(
            switchMap((s) => {
              const tagSystem = s.tag;
              const seekSystem = s.seek;
              if (tagSystem.prepared) {
                return EMPTY;
              }
              const remoteTagsTagStartOffset =
                seekSystem.seekOffsetBySeekId(SEEK_ID_KAX_TAGS);
              if (remoteTagsTagStartOffset! >= 0) {
                return createRangedEbmlStream({
                  ...options,
                  url,
                  byteStart: remoteTagsTagStartOffset,
                }).pipe(
                  switchMap((req) => req.ebml$),
                  filter(isTagIdPos(EbmlTagIdEnum.Tags, EbmlTagPosition.End)),
                  withLatestFrom(withMeta$),
                  map(([tags, withMeta]) => {
                    withMeta.tag.prepareWithTagsTag(tags);
                    return withMeta;
                  })
                );
              }
              return EMPTY;
            }),
            take(1),
            shareReplay(1)
          );

          const withLocalTags$ = withMeta$.pipe(
            switchMap((s) => (s.tag.prepared ? of(s) : EMPTY)),
            shareReplay(1)
          );

          const withCues$ = merge(withLocalCues$, withRemoteCues$).pipe(
            take(1)
          );

          const withoutCues$ = withCues$.pipe(
            isEmpty(),
            switchMap((empty) => (empty ? withMeta$ : EMPTY))
          );

          const withTags$ = merge(withLocalTags$, withRemoteTags$).pipe(
            take(1)
          );

          const withoutTags$ = withTags$.pipe(
            isEmpty(),
            switchMap((empty) => (empty ? withMeta$ : EMPTY))
          );

          const seekWithoutCues = (
            seekTime: number
          ): Observable<SegmentComponent<ClusterType>> => {
            const request$ = clusterStart$.pipe(
              switchMap((startTag) =>
                createRangedEbmlStream({
                  ...options,
                  url,
                  byteStart: startTag.startOffset,
                })
              )
            );
            const cluster$ = request$.pipe(
              switchMap((req) => req.ebml$),
              filter(isTagIdPos(EbmlTagIdEnum.Cluster, EbmlTagPosition.End)),
              map((tag) => clusterSystem.addClusterWithTag(tag))
            );

            if (seekTime === 0) {
              return cluster$;
            }

            return cluster$.pipe(
              scan(
                (prev, curr) =>
                  [prev?.[1], curr] as [
                    SegmentComponent<ClusterType> | undefined,
                    SegmentComponent<ClusterType> | undefined,
                  ],
                [undefined, undefined] as [
                  SegmentComponent<ClusterType> | undefined,
                  SegmentComponent<ClusterType> | undefined,
                ]
              ),
              filter((c) => c[1]?.Timestamp! > seekTime),
              map((c) => c[0] ?? c[1]!)
            );
          };

          const seekWithCues = (
            cueSystem: CueSystem,
            seekTime: number
          ): Observable<SegmentComponent<ClusterType>> => {
            if (seekTime === 0) {
              return seekWithoutCues(seekTime);
            }

            const cuePoint = cueSystem.findClosestCue(seekTime);

            if (!cuePoint) {
              return seekWithoutCues(seekTime);
            }

            return createRangedEbmlStream({
              ...options,
              url,
              byteStart: seekSystem.offsetFromSeekPosition(
                cueSystem.getCueTrackPositions(cuePoint)
                  .CueClusterPosition as number
              ),
            }).pipe(
              switchMap((req) => req.ebml$),
              filter(isTagIdPos(EbmlTagIdEnum.Cluster, EbmlTagPosition.End)),
              map(clusterSystem.addClusterWithTag.bind(clusterSystem))
            );
          };

          const seek = (
            seekTime: number
          ): Observable<SegmentComponent<ClusterType>> => {
            if (seekTime === 0) {
              const subscription = merge(withCues$, withoutCues$).subscribe();

              // if seekTime equals to 0 at start, reuse the initialize stream
              return seekWithoutCues(seekTime).pipe(
                finalize(() => {
                  subscription.unsubscribe();
                })
              );
            }
            return merge(
              withCues$.pipe(switchMap((s) => seekWithCues(s.cue, seekTime))),
              withoutCues$.pipe(switchMap((_) => seekWithoutCues(seekTime)))
            );
          };

          return {
            startTag,
            head$,
            segment,
            meta$,
            withMeta$,
            withCues$,
            withoutCues$,
            withTags$,
            withoutTags$,
            seekWithCues,
            seekWithoutCues,
            seek,
          };
        })
      );

      return {
        segments$,
        head$,
        totalSize,
        ebml$,
        controller,
        response,
      };
    }),
    shareReplay(1)
  );

  return {
    controller$,
    request$,
  };
}

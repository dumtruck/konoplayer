import type { CreateRangedStreamOptions } from '@konoplayer/core/data';
import { type EbmlEBMLTagType, EbmlTagIdEnum, EbmlTagPosition } from 'konoebml';
import {
  switchMap,
  filter,
  take,
  shareReplay,
  map,
  combineLatest,
  of,
} from 'rxjs';
import { isTagIdPos } from '../util';
import { createRangedEbmlStream } from './resource';
import { type MatroskaSegmentModel, createMatroskaSegment } from './segment';

export type CreateMatroskaOptions = Omit<
  CreateRangedStreamOptions,
  'byteStart' | 'byteEnd'
>;

export interface MatroskaModel {
  totalSize?: number;
  initResponse: Response;
  head: EbmlEBMLTagType;
  segment: MatroskaSegmentModel;
}

export function createMatroska(options: CreateMatroskaOptions) {
  const metadataRequest$ = createRangedEbmlStream({
    ...options,
    byteStart: 0,
  });

  return metadataRequest$.pipe(
    switchMap(({ totalSize, ebml$, response }) => {
      const head$ = ebml$.pipe(
        filter(isTagIdPos(EbmlTagIdEnum.EBML, EbmlTagPosition.End)),
        take(1),
        shareReplay(1)
      );

      const segmentStart$ = ebml$.pipe(
        filter(isTagIdPos(EbmlTagIdEnum.Segment, EbmlTagPosition.Start))
      );

      /**
       * while [matroska v4](https://www.matroska.org/technical/elements.html) doc tell that there is only one segment in a file
       * some mkv generated by strange tools will emit several
       */
      const segments$ = segmentStart$.pipe(
        map((startTag) =>
          createMatroskaSegment({
            startTag,
            matroskaOptions: options,
            ebml$,
          })
        )
      );

      return combineLatest({
        segment: segments$.pipe(take(1)),
        head: head$,
        totalSize: of(totalSize),
        initResponse: of(response),
      });
    }),
    shareReplay(1)
  );
}
